### 构造函数
- 类：函数数据类型
- 实例：对象数据类型

> new执行也会把类当作普通函数执行（当然也有类执行的一面）
- 1.创建一个私有的栈内存
- 2.形参赋值&变量提升
- 3.浏览器创建一个对象出来（这个对象是当前类的一个新实例），并且让函数中的this指向这个实例对象  =>“构造函数模式中，方法中的this是当前类的实例”
- 4.代码执行
- 5.在我们不设置return的情况下，浏览器会把创建的实例对象默认返回
#### 原型和原型链
- 1.每一个函数数据类型的值都有一个天生自带的属性：prototype（原型），这个属性的属性值是一个对象（用来存储实例公用的属性和方法的）
  + 普通函数
  + 类（自定义类和内置类）
- 2.在prototype这个对象中，也有一个天生自带的属性：constructor（构造函数），这个属性存储的是当前函数本身
```
Fn.prototype.constructor=Fn
```
- 3.每一个对象数据类型的值，也都有一个天生自带的属性：__proto__，这个属性指向“所属类的prototype”
  + 普通对象、数组、正则、Math、日期、类数组等等
  + 实例也是对象数据类型的值
  + 函数的原型prototype属性的值也是对象类型的
  + 函数也是对象数据类型的值
> 原型链查找机制
 - 1.先找自己的私有属性，有则调取，无则继续找
 - 2.基于___proto__找所属类的方法（Fn.prototype），如果还没有则继续基于___proto__往上找，一直找到Object.prototype为止
> ary.push(100) :ary这个数组实例，基于原型链查找机制，找到了Array.prototype上的push方法，并且把push方法执行（方法执行的作用是把100放到ary的末尾）
> 
#### hasOwnProperty
> 检测某一个属性名是否为当前对象的私有属性

- “in”：检测这个属性是否属于某个对象（不管是私有属性还是公有属性，只要是它的属性，结果就为true）
- 自己堆中有的属性是私有属性，需要基于__proto__查找的就是公有属性(__proto__在IE浏览器中（EDGE除外）给保护起来了，不让我们在代码中操作它)
## 难点：面向对象  发布订阅  ajax库封装  promiseA+  react-redux源码
> 面向对象中有关私有/公有方法中的this问题
- 1.方法执行，看前面是否有点，点前面是谁this就是谁
- 2.把方法中的this进行替换
- 3.再基于原型链查找的方法确定结果即可
> 基于内置类的原型扩展方法
- 1.在内置类原型上的方法，类所对应的实例可以直接调取使用，例如：实例.方法() 例：ary.push()如果我们写的方法放到原型上，那么当前类的实例也可以直接这样调取使用了，很方便
- 2.但是也是有需要注意的地方
  + 1.自己扩展的方法不能影响原有内置的方法（我们自己设置的方法最好加前缀：my）
  + 2.扩展方法中的this一般都是当前类的实例（也就是要操作的值）
> 链式写法（保证返回值依然是当前类的实例 一般都会return  this）
```
实例.__proto__===Fn.prototype(构造函数原型)
```