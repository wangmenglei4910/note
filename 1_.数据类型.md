## number数字类型
> 包含：常规数字、NaN
### NaN
> not a number :不是一个数，但他属于数字类型
NaN和任何值（包括自己）都不相等：NaN!=NaN,所以我们不能用相等的方式判断是否为有效数字
### isNaN
> 检验一个值是否为非有效数字，如果不是有效数字返回true，反之返回false。
> 检测机制：在使用isNaN检测时，首先会验证检测的值是否为数字类型，如果不是，先基于Number()这个方法，把值转化为数字类型，然后在检测。
### 把其他类型值转化为数字类型
- Number()
把字符串转化为数字，只要字符串中包含一个非有效数字字符（第一个点除外）结果都是NaN,空字符串''会变为0;
Number(null)  //0
Number(undefined) //NaN
Number('')  //0
Number([])   //0
把引用数据类型转化为数字，是先基于tostring方法转换为字符串，然后在转换为数字。
- parseInt()/parseFloat([val],[进制]),也是转换为数字的方法 ，对于字符串来说，他是从左到右依次进行查找有效字符，直到遇到非有效数字字符，停止查找（不管后面是否还有数字，都不在找了），把找到的当作数字返回。
- ==进行比较的时候，可能出现把其他类型值，转换为数字。
总结：
（Number''  []  null  false   都为0  Number（true）为1 ）两个字符串相比较
NaN==NaN//false 先转化为数字再比较    'NaN'==NaN//false 先转化为数字再比较  'NaN'=='NaN' //true    

与Boolean值比较时 也都是转换为数字 再进行比较
 先进行取反 ![](false) 再进行比较 false == false
    console.log(![] == false); // true     =>    0  ''  NaN  null underfined   这五个值转化为Boolean值都为false其余都为true

## string字符串的数据类型
> 所有用单引号，双引号，反引号(es6模板字符串)包起来的都是字符串。
### 把其他类型值转换为字符串
- [val].tostring()
- 字符串拼接
- null undefined禁止使用 to.string()方法，报错。转化结果是'null'  'undefined'
- 普通对象.tostring()结果是"[object Object]"      =>Object.prototype.tostring方法不是转换为字符串的，而是用来检验数据类型的。
- 四则运算法则中，除加法之外，其余都是数学运算，只有加法可能存在字符串拼接（一旦遇到字符串，则不是数学运算，而是字符串拼接）

## Boolean布尔数据类型
> 只有两个值 true/false
- 0  ''  NaN  null underfined   这五个值转化为Boolean值都为false其余都为true 
- !:取反（先转换为布尔，再取反）
- !!作用相当于布尔Boolean
- 如果条件只是一个值，不是==/===/!=/>=等这些比较，是要把这个值先转换为布尔类型，然后验证真假。

## null/undefined
> null和undefined 都代表是没有
- null：意料之中（一般都是开始不知道值，我们手动先设置为null，后期再给予赋值操作）
一般最好用null作为初始值的空值，因为零不是空值，他在栈内存中有自己的存储空间（占了位置）
- undefined:意料之外（不是我能决定的）
创建一个变量没有赋值，默认值就是undefined
## object对象数据类型-普通对象
> {[key]:[val,...]}任何一个对象都是由零到多组键值对（属性名：属性值）组成的（并且属性名不能重复）
- 获取属性名对应的属性值 对象.属性名  /对象[属性名]属性名是数字或者字符串格式的。
- 如果当前属性名不存在，默认属性值是undefined
- 如果属性名是数字，则不能用点的方式获取属性值
- 设置属性名属性值
属性名不能重复，如果属性名已经存在，不属于新增属于修改属性值
- 删除属性 真除：把属性名彻底干掉delete person.xx  假删除：属性还在，值为空 person.xx=null  
> 数组是特殊的对象数据类型
- 数组是特殊的对象
1.我们在中括号中设置的是属性值，他的属性名是默认生成的数字，从零开始递增，而且这个数字代表每一项的位置，我们把其称为“索引”=>从零开始，连续递增，代表每一项位置的数字属性名
2.天生默认一个属性名length，储存数组的长度  第一项索引为0，最后一项索引为ary.length-1
- 向数组末尾追加内容ary[ary.length]=xxx;
> 堆栈内存
- 浏览器想要执行代码：
1.从电脑内存中分配出一块内存，用来执行代码（栈内存=>stack）
2.浏览器还要分配一个主线程用来自上而下执行js代码
- let a=12存贮的过程
1.创建变量a，放到当前栈内存变量存储区域中
2.创建一个值12，把它存储到当前栈内存值存储区域中（简单的基本类型值是这样存储的，复杂的引用类型值不是这样做的）
3.=为赋值，其实赋值是让变量和值相互关联的过程
- 复杂值的存储过程，又分成三个步骤：
1.在内存中分配出一块新内存，用来存储引用类型值（堆内存=>heap =>内存有一个16进制地址）
2.把对象中的键值对依次存储到堆内存中
3.把堆内存地址和变量关联起来
- 基本类型是：按值操作（直接操作的是值）所以也叫做值类型
- 引用类型是：操作的是堆内存的地址（按引用地址操作的）
# 连等 a=b=10   相当于先a=10,然后b=10
```
阿里面试题：
let a ={n:1};
let b = a;
a.x = a = {n:2}
console.log(a.x,b)
```

### js数据类型检测
> typeof [val]:用来检测数据类型的运算符
- 基于typeof检测出来的的结果：
1.首先是一个字符串
2.字符串中包含对应的类型
1.typeof null =>"object" 但是null并不是对象
2.基于typeof无法细分出当前值是普通对象还是数组对象等，因为只要是对象数据类型，返回的结果都是"object"
- 因为typeof检测结果都是字符串，所以只要两个及以上同时检测，最后结果必然是"string" 例：console.log(typeof typeof typeof [])

> instanceof:用来检验当前实例是否率属于某个类
> constructor：基于构造函数检验数据类型（也是基于类的方法）
> Object.prototype.toString.call():检验数据类型最好的方法 





